类的本质：
1.class本质还是function
2.类的所有方法都定义在类的prototype属性上
3.类创建也有__Porto__指向类的prototype原型对象
4.语法糖：有两种方法可以实现同样的功能，但是一种写法更加清晰，方便，那么这个方法就是语法糖


forEach和some和filter的区别
forEach()：没有return true； 不终止循环
some()：遇到return true； 终止循环
every()：只要有一个是false，便返回false
filter()：遇到return 不会终止迭代


this 指向
普：window通函数调用
构造函数调用：实例对象 原型对象里面的方法也指向实例对象
对象方法调用：该方法所属对象
事件绑定方法：绑定事件对象
定时器函数：window
立即执行函数：window


call apply bind 总结0
相同点：都可以改变函数内部this指向

区别点：
1.call 和apply 会调用函数 并且改变函数内部this 指向
2.call 和apply传递的参数不一样， call传递参数aru1,aru2形式，apply必须数组形式
3.bind 不会调用函数，可以改变函数内部的this指向

主要应用场景：
1.call经常做继承
2.apply经常跟数组有关系，比如借助于数学对象实现数值最大值，最小值
3.bind 不会调用函数，但是还想改变this指向，比如定时器内的this指向


严格模式 'use strict'
1.消除了JavaScript语法的一些不合理，不严谨之处，减少一些怪异行为
2.消除代码运行的一些不安全之处，保证代码运行的安全
3.提高编译器效果，增加运行速度
4.禁用了ECMAscript的为了版本可能会定义的一些语法，为未来新版本的JavaScript做好铺垫，比如一些保留字如：class，enum，export，extends，supre 不能做变量名

严格模式的变化 
1.变量名必须先声明再使用
2.不能随意删除以及声明好了的函数
3.严格模式下全局作用域函数中的 this 是 undefined
4.严格模式下，如果 构造函数不加new调用，this 会报错
5.new的实例化的构造函数指向创建的对象实例
6.定时器里面的this 还是指向 window
7.事件，对象还是指向调用者
8.严格模式下参数里面不允许重名


闭包：指有权访问另一个函数作用域中变量的函数
作用：延申了变量的作用范围

递归函数：函数内部自己调用自己，这个函数就是递归函数


正则表达式：
正则表达式里面不需要添加引号 不管是数值型还是字符型
\d:匹配0-9之间的任意数字 
\D:匹配所有0-9以外的字符
\w:匹配任意字符 数字 下划线
\W:除所有字母，数字和下划线以外的字符
\s:匹配空格（包括换行符，制表符，空格符等）
\S:匹配非空格字符



let 关键字： 1.let 声明的变量只在所处于的块级有效  
            2.在一个大括号中使用let关键字声明的变量才具有块级作用域  
            3.var关键字不具备这个特点   
            4.不存在变量提升
            5.暂时性死区
        好处：防止循环变量变成全局变量

const 关键字：1.具有块级作用域
             2.声明常量时必须赋值
             3.常量赋值后，值不能修改
             4. ary[0] = 111;//可以修改
                ary = [1,2];//报错


let const var的区别
1.使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象
2.使用let声明的变量，其作用域为所在语句的代码块内，不存在变量提升
3.使用const声明的变量，在后面出现的代码中不能再修改常量的值(基本数据类型的值不可以修改，复杂类型的值不可以修改，但值内部的数据可以更改)


数组解构：数值解构允许我们按照一一对应的关系从数组中提取然后将赋值给变量  (变量没有对应的值的话 那这个值就是undefined)
         对象解构允许我们使用变量的名字匹配对象的属性，匹配成功将对象属性的值赋给变量


箭头函数 () => {}： 用来简化函数定义语法的
                   在箭头函数中 如果函数中只有一句代码，并且代码执行的结果就是函数的返回值， 函数体大括号可以省略
                   在箭头函数中 如果形参只有一个形参外侧的小括号也是可以省略的
                   箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this

扩展运算符：可以将数组或者对象转为用逗号分隔的参数序列
           可以应用于合并数组
           利用扩展运算符将伪数组转为真正的数组


Array.from方法:可以把伪数组转化为真正的数组


find方法; .find(item,index) 可以传入两个值 item当前循环的值 index 当前值得索引号


fendindex：返回当前符合元素的索引号


includes()：表示某个数组是否包含给定的值，返回布尔值


模板字符串；可以解析变量
           模板字符串可以进行换行
           模板字符串可以调用函数


startsWith():表示参数字符是否在原字符串的头部，返回布尔值
endsWith():表示参数字符是否在原字符串的尾部，返回布尔值


repeat(n):方法表示将源字符串重复n次，返回一个新字符串


Set 数据结构：类似于数组，但是成员的值都是唯一的，没有重复的值
    s.add(value):添加某个值 返回Set结构本身
    s.delete(value):删除某个值 返回一个布尔值，表示删除是否成功
    s.has(value):返回一个布尔值，表示该值是否为Set的成员
    s.clear():清除所有成员，没有返回值
